<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DakotaGrammarRL: Composite Reward Visualizer</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.9.1/gsap.min.js"></script>
    <style>
        :root {
            --bg-color: #f8f9fa;
            --text-main: #2d3436;
            --text-light: #636e72;
            --accent-char: #00b894; /* Green for Orthography */
            --accent-morph: #0984e3; /* Blue for Morphology */
            --accent-sem: #e17055; /* Orange/Red for Semantics */
            --card-bg: rgba(255, 255, 255, 0.9);
            --shadow: 0 10px 30px rgba(0,0,0,0.08);
            --font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
        }

        body {
            margin: 0;
            overflow: hidden;
            background-color: var(--bg-color);
            font-family: var(--font-family);
            color: var(--text-main);
        }

        #canvas-container {
            width: 100vw;
            height: 100vh;
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
        }

        /* UI Overlay */
        .ui-panel {
            position: absolute;
            background: var(--card-bg);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            padding: 24px;
            border-radius: 16px;
            box-shadow: var(--shadow);
            z-index: 10;
            border: 1px solid rgba(255,255,255,0.5);
            transition: transform 0.3s ease;
        }

        .controls {
            top: 50%;
            left: 40px;
            transform: translateY(-50%);
            width: 320px;
        }

        .stats {
            top: 40px;
            right: 40px;
            width: 280px;
        }

        h1 {
            font-size: 1.2rem;
            margin: 0 0 8px 0;
            font-weight: 700;
            letter-spacing: -0.02em;
        }

        h2 {
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: var(--text-light);
            margin-bottom: 16px;
            margin-top: 24px;
            border-bottom: 1px solid #eee;
            padding-bottom: 8px;
        }

        .subtitle {
            font-size: 0.85rem;
            color: var(--text-light);
            margin-bottom: 20px;
            line-height: 1.4;
        }

        /* Inputs and Sliders */
        .control-group {
            margin-bottom: 16px;
        }

        .label-row {
            display: flex;
            justify-content: space-between;
            font-size: 0.85rem;
            margin-bottom: 6px;
            font-weight: 500;
        }

        .color-dot {
            display: inline-block;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            margin-right: 6px;
        }

        input[type=range] {
            width: 100%;
            -webkit-appearance: none;
            background: transparent;
        }

        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 16px;
            width: 16px;
            border-radius: 50%;
            background: #fff;
            border: 2px solid var(--text-light);
            cursor: pointer;
            margin-top: -6px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }

        input[type=range]::-webkit-slider-runnable-track {
            width: 100%;
            height: 4px;
            cursor: pointer;
            background: #dfe6e9;
            border-radius: 2px;
        }

        /* Scenarios Button Group */
        .scenario-btns {
            display: flex;
            gap: 8px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .scenario-btn {
            flex: 1;
            padding: 8px 12px;
            background: white;
            border: 1px solid #dfe6e9;
            border-radius: 8px;
            font-size: 0.8rem;
            cursor: pointer;
            transition: all 0.2s;
            font-weight: 600;
            color: var(--text-light);
        }

        .scenario-btn:hover {
            border-color: var(--text-main);
            color: var(--text-main);
        }

        .scenario-btn.active {
            background: var(--text-main);
            color: white;
            border-color: var(--text-main);
        }

        /* Total Score Display */
        .total-score-container {
            text-align: center;
            margin-top: 10px;
            padding-top: 10px;
            border-top: 1px solid #eee;
        }

        #total-score-display {
            font-size: 3rem;
            font-weight: 800;
            color: var(--text-main);
            line-height: 1;
        }

        .score-label {
            font-size: 0.9rem;
            color: var(--text-light);
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        /* Tooltip style explanation */
        .explanation {
            font-size: 0.8rem;
            color: var(--text-light);
            background: #f1f3f5;
            padding: 10px;
            border-radius: 8px;
            margin-top: 10px;
            line-height: 1.4;
        }

        /* Custom Range Colors */
        #range-char::-webkit-slider-thumb { border-color: var(--accent-char); }
        #range-morph::-webkit-slider-thumb { border-color: var(--accent-morph); }
        #range-sem::-webkit-slider-thumb { border-color: var(--accent-sem); }

    </style>
</head>
<body>

    <div id="canvas-container"></div>

    <div class="ui-panel controls">
        <h1>DakotaGrammarRL</h1>
        <div class="subtitle">Composite Reward Function Visualizer based on Cooper (2025).</div>

        <h2>Select Scenario</h2>
        <div class="scenario-btns">
            <button class="scenario-btn active" onclick="setScenario('perfect')">Perfect</button>
            <button class="scenario-btn" onclick="setScenario('badChar')">Bad Char</button>
            <button class="scenario-btn" onclick="setScenario('badMorph')">Bad Morph</button>
        </div>

        <div id="scenario-text" class="explanation">
            <strong>Input:</strong> wićašta (man) + pi (plural)<br>
            <strong>Output:</strong> "wićaštapi"<br>
            All constraints satisfied.
        </div>

        <h2>Component Scores (Performance)</h2>
        
        <div class="control-group">
            <div class="label-row">
                <span><span class="color-dot" style="background:var(--accent-char)"></span>R_char (Character)</span>
                <span id="val-char">1.0</span>
            </div>
            <input type="range" id="range-char" min="0" max="1" step="0.01" value="1.0">
        </div>

        <div class="control-group">
            <div class="label-row">
                <span><span class="color-dot" style="background:var(--accent-morph)"></span>R_morph (Affix)</span>
                <span id="val-morph">1.0</span>
            </div>
            <input type="range" id="range-morph" min="0" max="1" step="0.01" value="1.0">
        </div>

        <div class="control-group">
            <div class="label-row">
                <span><span class="color-dot" style="background:var(--accent-sem)"></span>R_sem (Semantic)</span>
                <span id="val-sem">1.0</span>
            </div>
            <input type="range" id="range-sem" min="0" max="1" step="0.01" value="1.0">
        </div>

    </div>

    <div class="ui-panel stats">
        <h1>Reward Composition</h1>
        <div class="subtitle">Adjust weights ($\alpha, \beta, \gamma$) to see how priority shifts impact learning.</div>

        <div class="control-group">
            <div class="label-row">
                <span>Weight $\alpha$ (Char)</span>
                <span id="weight-char">0.4</span>
            </div>
            <input type="range" id="w-char" min="0" max="1" step="0.1" value="0.4">
        </div>

        <div class="control-group">
            <div class="label-row">
                <span>Weight $\beta$ (Morph)</span>
                <span id="weight-morph">0.4</span>
            </div>
            <input type="range" id="w-morph" min="0" max="1" step="0.1" value="0.4">
        </div>

        <div class="control-group">
            <div class="label-row">
                <span>Weight $\gamma$ (Sem)</span>
                <span id="weight-sem">0.2</span>
            </div>
            <input type="range" id="w-sem" min="0" max="1" step="0.1" value="0.2">
        </div>

        <div class="control-group">
            <div class="label-row">
                <span>Difficulty $\lambda$</span>
                <span id="val-lambda">1.0</span>
            </div>
            <input type="range" id="range-lambda" min="1.0" max="2.0" step="0.5" value="1.0">
        </div>

        <div class="total-score-container">
            <div id="total-score-display">1.00</div>
            <div class="score-label">Total Reward ($R_{total}$)</div>
        </div>
    </div>

    <script>
        // --- 1. State Management ---
        const state = {
            scores: { char: 1.0, morph: 1.0, sem: 1.0 },
            weights: { char: 0.4, morph: 0.4, sem: 0.2 },
            lambda: 1.0,
            total: 1.0
        };

        // --- 2. Three.js Setup ---
        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        // Soft gradient background via fog
        scene.background = new THREE.Color(0xf8f9fa);
        scene.fog = new THREE.Fog(0xf8f9fa, 10, 30);

        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 100);
        camera.position.set(5, 5, 8);
        camera.lookAt(0, 1.5, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        container.appendChild(renderer.domElement);

        // Lights
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);

        const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
        dirLight.position.set(5, 10, 7);
        dirLight.castShadow = true;
        dirLight.shadow.mapSize.width = 2048;
        dirLight.shadow.mapSize.height = 2048;
        scene.add(dirLight);

        const spotLight = new THREE.SpotLight(0xffffff, 0.5);
        spotLight.position.set(-5, 8, 0);
        scene.add(spotLight);

        // Materials
        const baseMaterial = new THREE.MeshStandardMaterial({ 
            color: 0xffffff, 
            roughness: 0.8,
            metalness: 0.1
        });

        // Glass Material for the containers
        const glassMaterial = new THREE.MeshPhysicalMaterial({
            color: 0xffffff,
            metalness: 0.1,
            roughness: 0.05,
            transmission: 0.9, // Add transparency
            transparent: true,
            opacity: 0.3,
            thickness: 0.5,
        });

        // Materials for the liquid bars (Emissive for glow)
        const matChar = new THREE.MeshPhysicalMaterial({ 
            color: 0x00b894, emissive: 0x00b894, emissiveIntensity: 0.2, roughness: 0.2, metalness: 0.1 
        });
        const matMorph = new THREE.MeshPhysicalMaterial({ 
            color: 0x0984e3, emissive: 0x0984e3, emissiveIntensity: 0.2, roughness: 0.2, metalness: 0.1 
        });
        const matSem = new THREE.MeshPhysicalMaterial({ 
            color: 0xe17055, emissive: 0xe17055, emissiveIntensity: 0.2, roughness: 0.2, metalness: 0.1 
        });

        // --- 3. Scene Construction ---
        
        // Platform
        const platformGeo = new THREE.CylinderGeometry(4, 4, 0.2, 64);
        const platform = new THREE.Mesh(platformGeo, baseMaterial);
        platform.position.y = -0.1;
        platform.receiveShadow = true;
        scene.add(platform);

        // Grid helper
        const grid = new THREE.GridHelper(20, 20, 0x000000, 0x000000);
        grid.material.opacity = 0.05;
        grid.material.transparent = true;
        scene.add(grid);

        // Bar Objects Container
        const bars = {};
        
        function createBarUnit(x, z, material, name) {
            const group = new THREE.Group();
            group.position.set(x, 0, z);

            // Glass Container
            const housingGeo = new THREE.BoxGeometry(1, 4.2, 1);
            // shift up so bottom is at 0
            housingGeo.translate(0, 2.1, 0); 
            const housing = new THREE.Mesh(housingGeo, glassMaterial);
            housing.castShadow = true;
            group.add(housing);

            // The Liquid (Score)
            const liquidGeo = new THREE.BoxGeometry(0.8, 1, 0.8);
            liquidGeo.translate(0, 0.5, 0); // pivot at bottom
            const liquid = new THREE.Mesh(liquidGeo, material);
            liquid.scale.y = 0.01; // Start empty
            group.add(liquid);

            // Label
            // Since font loading is async and complex in single-file, we rely on the UI panel for labels,
            // but we can add simple color indicators on the ground.
            const indicatorGeo = new THREE.CircleGeometry(0.6, 32);
            indicatorGeo.rotateX(-Math.PI / 2);
            const indicator = new THREE.Mesh(indicatorGeo, material);
            indicator.position.y = 0.01;
            group.add(indicator);

            scene.add(group);
            return { group, liquid };
        }

        // Create the three towers
        bars.char = createBarUnit(-1.5, 0, matChar, 'Char');
        bars.morph = createBarUnit(0, 0, matMorph, 'Morph');
        bars.sem = createBarUnit(1.5, 0, matSem, 'Sem');

        // Total Reward Indicator (Floating Ring)
        const ringGeo = new THREE.TorusGeometry(3, 0.05, 16, 100);
        const ringMat = new THREE.MeshBasicMaterial({ color: 0x2d3436, transparent: true, opacity: 0.2 });
        const ring = new THREE.Mesh(ringGeo, ringMat);
        ring.rotation.x = Math.PI / 2;
        ring.position.y = 0.1;
        scene.add(ring);

        // --- 4. Animation Loop ---
        function animate() {
            requestAnimationFrame(animate);
            
            // Gentle Rotation
            const time = Date.now() * 0.0005;
            scene.rotation.y = Math.sin(time * 0.2) * 0.05; // Subtle swing
            
            // Hover effect for ring
            ring.position.y = 0.2 + Math.sin(time) * 0.05;

            renderer.render(scene, camera);
        }
        animate();

        // --- 5. Interaction Logic ---

        function updateMath() {
            // Apply formula: R = lambda * (alpha*char + beta*morph + gamma*sem)
            // Note: Visual height corresponds to the Weighted contribution
            // Max height of container is roughly 4 units.
            
            // Normalize weights visually if needed, but for the math we use raw values
            const wC = parseFloat(state.weights.char);
            const wM = parseFloat(state.weights.morph);
            const wS = parseFloat(state.weights.sem);
            
            const sC = parseFloat(state.scores.char);
            const sM = parseFloat(state.scores.morph);
            const sS = parseFloat(state.scores.sem);
            
            const lambda = parseFloat(state.lambda);

            // Calculate contributions
            const contChar = sC * wC;
            const contMorph = sM * wM;
            const contSem = sS * wS;

            const baseTotal = contChar + contMorph + contSem;
            state.total = baseTotal * lambda;

            // Visual Scaling (Max height approx 4.0)
            // We scale the visual bar based on Score (fullness) * Weight (size context)
            // Actually, let's make the LIQUID height represent the SCORE (0-100% full)
            // And the width/opacity or glow represent the WEIGHT? 
            // Better: Liquid Height = Score. 
            // But to show contribution, let's map Liquid Height to Contribution * 4.
            // If Weight is 0.4 and Score is 1.0, Height is 0.4 * 4 = 1.6
            
            const scaleFactor = 4.0; // Max physical height in 3D units

            // GSAP Animations for smooth transitions
            gsap.to(bars.char.liquid.scale, { y: Math.max(0.01, sC * scaleFactor), duration: 0.5, ease: "power2.out" });
            gsap.to(bars.morph.liquid.scale, { y: Math.max(0.01, sM * scaleFactor), duration: 0.5, ease: "power2.out" });
            gsap.to(bars.sem.liquid.scale, { y: Math.max(0.01, sS * scaleFactor), duration: 0.5, ease: "power2.out" });

            // Adjust Opacity based on weight (higher weight = more solid)
            // We animate the materials
            bars.char.liquid.material.opacity = 0.5 + (wC * 0.5);
            bars.morph.liquid.material.opacity = 0.5 + (wM * 0.5);
            bars.sem.liquid.material.opacity = 0.5 + (wS * 0.5);

            // Update DOM
            document.getElementById('val-char').innerText = sC.toFixed(2);
            document.getElementById('val-morph').innerText = sM.toFixed(2);
            document.getElementById('val-sem').innerText = sS.toFixed(2);
            
            document.getElementById('weight-char').innerText = wC.toFixed(1);
            document.getElementById('weight-morph').innerText = wM.toFixed(1);
            document.getElementById('weight-sem').innerText = wS.toFixed(1);

            document.getElementById('val-lambda').innerText = lambda.toFixed(1);
            
            // Total Score Animation
            const scoreDisplay = document.getElementById('total-score-display');
            // Animate number
            const currentObj = { val: parseFloat(scoreDisplay.innerText) };
            gsap.to(currentObj, {
                val: state.total,
                duration: 0.3,
                onUpdate: () => {
                    scoreDisplay.innerText = currentObj.val.toFixed(2);
                }
            });
        }

        // --- 6. Event Listeners ---

        // Score Sliders
        document.getElementById('range-char').addEventListener('input', (e) => { state.scores.char = e.target.value; updateMath(); clearScenarioBtns(); });
        document.getElementById('range-morph').addEventListener('input', (e) => { state.scores.morph = e.target.value; updateMath(); clearScenarioBtns(); });
        document.getElementById('range-sem').addEventListener('input', (e) => { state.scores.sem = e.target.value; updateMath(); clearScenarioBtns(); });

        // Weight Sliders
        document.getElementById('w-char').addEventListener('input', (e) => { state.weights.char = e.target.value; updateMath(); });
        document.getElementById('w-morph').addEventListener('input', (e) => { state.weights.morph = e.target.value; updateMath(); });
        document.getElementById('w-sem').addEventListener('input', (e) => { state.weights.sem = e.target.value; updateMath(); });
        document.getElementById('range-lambda').addEventListener('input', (e) => { state.lambda = e.target.value; updateMath(); });

        // Scenarios
        function clearScenarioBtns() {
            document.querySelectorAll('.scenario-btn').forEach(b => b.classList.remove('active'));
        }

        window.setScenario = function(type) {
            clearScenarioBtns();
            const btns = document.querySelectorAll('.scenario-btn');
            const explanation = document.getElementById('scenario-text');

            if(type === 'perfect') {
                btns[0].classList.add('active');
                state.scores = { char: 1.0, morph: 1.0, sem: 1.0 };
                explanation.innerHTML = `<strong>Input:</strong> wićašta (man) + pi (plural)<br><strong>Output:</strong> "wićaštapi"<br><span style="color:var(--accent-char)">✓ Special chars preserved</span> <span style="color:var(--accent-morph)">✓ Suffix correct</span>`;
            } else if (type === 'badChar') {
                btns[1].classList.add('active');
                state.scores = { char: 0.2, morph: 1.0, sem: 0.9 }; // Low char, high morph
                explanation.innerHTML = `<strong>Input:</strong> wićašta + pi<br><strong>Output:</strong> "wicastapi"<br><span style="color:#d63031">✗ "c"/"s" used instead of "ć"/"š"</span><br><span style="color:var(--accent-morph)">✓ Morphology (-pi) is still valid</span>`;
            } else if (type === 'badMorph') {
                btns[2].classList.add('active');
                state.scores = { char: 1.0, morph: 0.0, sem: 0.5 }; 
                explanation.innerHTML = `<strong>Input:</strong> wićašta + pi<br><strong>Output:</strong> "wićašta"<br><span style="color:var(--accent-char)">✓ Characters correct</span><br><span style="color:#d63031">✗ Failed to apply plural suffix</span>`;
            }

            // Update Inputs
            document.getElementById('range-char').value = state.scores.char;
            document.getElementById('range-morph').value = state.scores.morph;
            document.getElementById('range-sem').value = state.scores.sem;

            updateMath();
        }

        // Handle Window Resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Initial Call
        updateMath();

    </script>
</body>
</html>